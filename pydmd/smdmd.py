"""Sparse Mode DMD module"""

from copy import deepcopy
from typing import Any, Dict, NamedTuple, Union

import numpy as np

from .dmd import DMD
from .dmd_modes_tuner import BOUND, sparsify_modes


class SMDMD(DMD):
    r"""Sparsify DMD modes, assuming the underlying signal is generated by sparse modes.
        The modes :math:`\boldsymbol{\Phi}` are sparse if they consinst of mainly of complex numbers
        s.t. :math:`\boldsymbol{\Phi}_{ij} = 0 + 0j`. The modes can be further bounded,
        which is achieved by a combination of SR3 (https://ieeexplore.ieee.org/document/8573778)
        and a complex valued Quadratic Program using OSQP (https://web.stanford.edu/~boyd/papers/pdf/osqp.pdf).

    :param svd_rank: the rank for the truncation; If 0, the method computes the
        optimal rank and uses it for truncation; if positive interger, the
        method uses the argument for the truncation; if float between 0 and 1,
        the rank is the number of the biggest singular values that are needed
        to reach the 'energy' specified by `svd_rank`; if -1, the method does
        not compute truncation.
    :type svd_rank: int or float
    :param int tlsq_rank: rank truncation computing Total Least Square. Default
        is 0, that means TLSQ is not applied.
    :param bool exact: flag to compute either exact DMD or projected DMD.
        Default is False.
    :param opt: argument to control the computation of DMD modes amplitudes.
        See :class:`DMDBase`. Default is False.
    :type opt: bool or int
    :param rescale_mode: Scale Atilde as shown in
            10.1016/j.jneumeth.2015.10.010 (section 2.4) before computing its
            eigendecomposition. None means no rescaling, 'auto' means automatic
            rescaling using singular values, otherwise the scaling factors.
    :type rescale_mode: {'auto'} or None or numpy.ndarray
    :param bool forward_backward: If True, the low-rank operator is computed
        like in fbDMD (reference: https://arxiv.org/abs/1507.02264). Default is
        False.
    :param sorted_eigs: Sort eigenvalues (and modes/dynamics accordingly) by
        magnitude if `sorted_eigs='abs'`, by real part (and then by imaginary
        part to break ties) if `sorted_eigs='real'`. Default: False.
    :type sorted_eigs: {'real', 'abs'} or False
    :param tikhonov_regularization: Tikhonov parameter for the regularization.
        If `None`, no regularization is applied, if `float`, it is used as the
        :math:`\lambda` tikhonov parameter.
    :type tikhonov_regularization: int or float
    :param: qp_max_iter: Maximum number of iterations for underlying quadratic program, defaults to 10.
    :type qp_max_iter: int
    :param alpha: Regularization parameter for modes. Higher values lead to smaller values within the modes. Defaults to 1.
    :type alpha: float
    :param beta: Controls how strong the modes real- and complex components are driven to zero. Depending on parameter `prox_operator` the behaviour varies.
        If `prox_operator="hard_threshold"` components are set to zero if :math:`\lvert z \rvert < \beta`.
        If `prox_operator="prox_l1", higher values of `beta` drive the real- and complex parts of the modes to zero in a more aggressive manner.
    :type beta: float
    :param rb: Lower- and upper bound for real values of the modes. Modes include their corresponding amplitude during optimization.
        If set to `rb=None`, the bounds are set to `BOUND(-inf, +inf)`. For just a lower bound set `rb=BOUND(val_low, None)`, for an upper bound set `rb=BOUND(None, val_up)`,
        for lower- and upper bound set `rb=BOUND(val_low, val_up)`. Defaults to None
    :type: namedtuple
    :param ib: Lower- and upper bound for imaginary values of the modes. Modes include their corresponding amplitude during optimization.
        If set to `ib=None`, the bounds are set to `BOUND(-inf, +inf)`. For just a lower bound set `ib=BOUND(val_low, None)`, for an upper bound set `ib=BOUND(None, val_up)`,
        for lower- and upper bound set `ib=BOUND(val_low, val_up)`. Defaults to None
    :type: namedtuple
    :param osqp_settings: Additional solver settings for the OSQP solver. Please confer https://osqp.org/docs/interfaces/solver_settings.html for more details.
       If `osqp_settings=None`, internally default parameters are allocated s.t. `osqp_settings = {"max_iter": int(1e6), "eps_abs"=1e-6, verbose: False}`.
       Defaults to None.
    type osqp_settings: Dict[str, Any]
    """

    def __init__(
        self,
        svd_rank: Union[int, float] = 0,
        tlsq_rank: Union[int, float] = 0,
        exact: bool = False,
        opt: bool = False,
        rescale_mode=None,
        forward_backward: bool = False,
        sorted_eigs: bool = False,
        tikhonov_regularization: float = None,
        qp_max_iter: int = 10,
        alpha: float = 1.0,
        beta: float = 1e-4,
        prox_operator: str = "prox_l1",
        rb: NamedTuple(
            "bound",
            [("lower", Union[float, int]), ("upper", Union[float, int])],
        ) = None,
        ib: NamedTuple(
            "bound",
            [("lower", Union[float, int]), ("upper", Union[float, int])],
        ) = None,
        osqp_settings: Dict[str, Any] = None,
    ):
        super().__init__(
            svd_rank,
            tlsq_rank,
            exact,
            opt,
            rescale_mode,
            forward_backward,
            sorted_eigs,
            tikhonov_regularization,
        )
        self._qp_maxiter: int = qp_max_iter
        self._rb: BOUND = rb
        self._ib: BOUND = ib
        self._alpha: float = alpha
        self._beta: float = beta
        self._prox: str = prox_operator
        self._osqp_settings: Dict[str, Any] = osqp_settings

    def fit(self, X, Y=None):
        """
        Compute the Dynamic Modes Decomposition to the input data.

        :param X: the input snapshots.
        :type X: numpy.ndarray or iterable
        :param Y: additional input snapshots such that Y=AX.
            If not provided, snapshots from X are used.
        :type Y: numpy.ndarray or iterable
        """
        # protect dmd_time from overwrite
        dmd_time = deepcopy(self.dmd_time)
        super().fit(X, Y)
        self.dmd_time = dmd_time
        time = self.dmd_timesteps
        omegas = np.log(self.eigs) / self.dmd_time["dt"]

        data_in = (
            X
            if Y is None
            else np.concatenate(
                [self.snapshots, self.snapshots_y[:, -1, None]], axis=-1
            )
        )

        # Sparsify modes
        new_modes, new_amps, ok_idx = sparsify_modes(
            omegas,
            time,
            data_in,
            self._alpha,
            self._beta,
            self._qp_maxiter,
            self._rb,
            self._ib,
            self._osqp_settings,
            self._prox,
        )

        self.operator._modes = new_modes
        self.operator._eigenvalues = self.eigs[ok_idx]
        self._b = new_amps
        self._eigs = self.eigs[ok_idx]
        self._allocate_modes_bitmask_proxy()
        return self
